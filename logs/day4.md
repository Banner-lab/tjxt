****
#### 今日面试题总结
播放进度在服务端保存在哪里？是数据库吗？如果是数据库，如何解决高频写入给数据库带来巨大压力？
提交播放记录最终肯定会保存在数据库中，因为我们不仅要做视频续播，还有用户学习计划、学习进度统计等功能，都需要用到用户的播放记录数据
为了解决高频写入来的数据库并发压力问题，采用了合并写请求的方案，当用户提交播放进度时会先缓存在Redis中，后续再将数据保存到数据库即可
因为播放进度会不断覆盖，只保留最后一次即可。这样就可以大大减少对于数据库的访问次数和访问频率。
#### 缓存双写一致性
##### 双检加锁策略
多个线程同时去查询数据库的一条数据，那么我们可以在第一个查询这条数据的请求上使用一个互斥锁来锁住它。其他的线程走到这一步无法获取锁而进行等待，直到第一个线程查询出了数据并放到缓存里，释放锁资源，后面的线程进来发现已经有了缓存直接走缓存
>给缓存设置过期时间，定期清理缓存并回写，是保证最终一致性的解决方案。

在大多数业务场景下，优先使用先更新数据库，再删除缓存的方案，理由如下：
1. 先删除缓存值再更新数据库，有可能出现请求因缓存缺失而访问数据库，给数据库带来压力导致打满mysql
2. 如果业务应用中读取数据库和写缓存的时间不好估算，那么，延迟双删中的等待时间就不好设置
#### 单机并发能力
在机器性能一定的情况下，提高单机并发能力就是要尽可能缩短业务的响应时间，对响应时间影响最大的往往是对数据库的操作，而从数据库的角度出发，基本就是读或写操作。
对于读多写少的业务，一般情况下我们选择的优化手段为：
* 优化代码及sql
* 添加缓存
对于写操作频繁的业务来说，优化方案有：
* 优化代码及sql
* 变同步写为异步写
* 合并写请求
##### 同步写变异步写
使用mq可以将同步业务变成异步：
* 当我们接收到用户请求后，先不处理业务，而是发送mq消息并返回给用户结果
* 通过消息监听器监听mq消息，处理后续业务
这样一来，用户请求处理和后续数据库写就从同步变为异步，用户无需等待后续的数据库写操作，响应时间自然会大大缩短。并发能力自然大大提高。
**优点**：
* 无需等待复杂业务处理，大大减少响应时间
* 利用mq暂存消息，起到流量削峰作用
* 降低写数据库频率，减轻数据库并发压力
**缺点**：
* 依赖于mq的可靠性
* 降低了频率，但是没有减少数据库写次数
#### 合并写请求
合并写请求方案其实是参考高并发读的优化思路：当读数据库并发较高时，我们可以把数据缓存到Redis，这样就无需访问数据库，大大减少数据库压力，减少响应时间。
将数据先缓存到Redis中，积累一些数据后再批量写入数据库，这样数据库的写频率、写次数都大大减少，对数据库压力小了非常多。
**优点**：
* 写缓存速度快，响应时间大大减少
* 降低数据库的写频率和写次数，大大减轻数据库压力
**缺点**：
* 实现相对复杂
* 依赖Redis可靠性
* 不支持事务和复杂业务
#### 播放进度记录方案改进
项目中学习进度统计涉及到了大量的数据库写操作即视频的播放进度写入数据库，因为前端每隔15秒就提交一次请求记录视频进度，大多数情况下都是更新一下播放进度即可，而播放进度信息，不管更新多少次，写一次续播肯定是从最后一次播放进度开始续播，也就是说我们只需要将最后一次视频进度存入数据库。
那么优化的方向就很明确了，使用合并写请求方案将视频进度信息记录在Redis缓存中，最后一次视频播放时再将视频进度即moment写入Mysql数据库
##### Redis数据结构设计
这条业务支线的流程如下：
- 查询播放记录，判断是否存在
    
    - 如果不存在，新增一条记录
        
    - 如果存在，则更新学习记录
        
- 判断当前进度是否是第一次学完
    
    - 播放进度要超过50%
        
    - 原本的记录状态是未学完
        
- 更新课表中最近学习小节id、学习时间
    
这里有多次数据库操作，例如：
- 查询播放记录：需要知道播放记录是否存在、播放记录当前的完成状态
    
- 更新播放记录：更新播放进度
    
- 更新最近学习小节id、时间
一方面我们要缓存写数据，减少写数据库频率；另一方面我们要缓存播放记录，减少查询数据库，因此缓存中至少要包括3个字段：
1. 学习记录id
2. 播放进度：moment，用户缓存播放进度
3. 播放状态（是否学完）:finished,用户判断是否是第一次学完
优化步骤为：
* 提交播放进度后，如果是更新播放进度则不写数据库，而是写缓存
* 需要一个定时任务，定期将缓存数据写入数据库
变化后的业务具体流程为：

- 1.提交学习记录
    
- 2.判断是否是考试
    
    - 是：新增学习记录，并标记有小节被学完。走步骤8
        
    - 否：走视频流程，步骤3
        
- 3.查询播放记录缓存，如果缓存不存在则查询数据库并建立缓存
    
- 4.判断记录是否存在
    
    - 4.1.否：新增一条学习记录
        
    - 4.2.是：走更新学习记录流程，步骤5
        
- 5.判断是否是第一次学完（进度超50%，旧的状态是未学完）
    
    - 5.1.否：仅仅是要更新播放进度，因此直接写入Redis并结束
        
    - 5.2.是：代表小节学完，走步骤6
        
- 6.更新学习记录状态为已学完
    
- 7.清理Redis缓存：因为学习状态变为已学完，与缓存不一致，因此这里清理掉缓存，这样下次查询时自然会更新缓存，保证数据一致。
    
- 8.更新课表中已学习小节的数量+1
    
- 9.判断课程的小节是否全部学完
    
    - 是：更新课表状态为已学完
        
    - 否：结束
##### 持久化思路
对于合并写请求方案，一定有一个步骤就是持久化缓存数据到数据库，一般采用的是定时任务持久化
但是定时任务持久化存在时效性问题：
* 假如定时任务间隔较短，例如20s一次，对数据库的更新频率太高，压力太大
* 假如定时任务间隔较长，例如2分钟一次，更新频率较低，续播误差可能超过2分钟，不满足需求
考虑到视频续播的起点是视频最后一次提交的播放进度来续播，我们只需要将最后一次提交的播放进度写入数据库
问题的关键在于如何确定哪一次提交是最后一次提交？
> 前端提交播放记录时，我们可以设置一个延迟任务并保存这次提交的进度，等待20秒后（等待下一次提交），检查Redis缓存中的缓存进度与任务中的进度是否一致
不一致说明持续再提交无需处理，反之则说明是最后一次提交，更新学习记录，更新课表最近学习小节和时间到数据库中

##### 延迟任务
为了确定用户提交的播放记录是否变化，我们需要将播放记录保存为一个延迟任务，等待超过一个提交周期（20s）后检查播放进度。
###### DelayQueue原理
DelayQueue实现了BlockingQueue接口，是一个阻塞队列。队列就是容器，用来存储延迟执行的任务。
DelayQueue泛型定义
```
DelayQueue<E extends Delayed>
```
这说明存入`DelayQueue`内部的元素必须是`Delayed`类型
```
public interface Delayed extends Comparable<Delayed> {

    /**
     * Returns the remaining delay associated with this object, in the
     * given time unit.
     *
     * @param unit the time unit
     * @return the remaining delay; zero or negative values indicate
     * that the delay has already elapsed
     */
    long getDelay(TimeUnit unit);
}
```
Delayed类型的延迟任务具备两个功能：获取剩余延迟时间、比较执行顺序。
将来每一次提交播放记录，就可以将播放记录保存在这样的Delayed类型的延迟任务里并设定20秒的延迟时间，交给延迟队列。这样DelayQueue会调用compareTo方法，根据延迟时间对任务排序，剩余延迟时间越短的越靠近队首，这样就会被优先执行。
##### 定义延迟任务工具类
![avatar](img/168683905614413.png)
从流程图可以分析出，工具类应该具备上述四个方法：
* 添加播放记录到Redis缓存中，并添加一个延迟检测任务到DelayQueue
* 查询Redis缓存中指定小节的播放记录
* 删除Reis缓存中指定小节的播放记录
* 异步执行DelayQueue中的延迟检测任务，检测播放进度是否变化，如果无变化则写入数据库