****
# 兑换码兑换优惠券
兑换码兑换优惠券时，首先需要我们需要通过解析获得兑换码序列号即id，然后根据id在Redis中我们存放的用来校验兑换码的bitMap来校验兑换码是否使用过。接着根据id查询数据库中exchange_code表中exchange_target_id字段，即可知道要兑换的优惠券id。
## 兑换码是否兑换
这里项目中使用了bitMap实现，因为在高并发的情况下，访问数据库查询exchange_code表来校验显然不现实，很容易打挂数据库。而且一个兑换码仅使用一个bit就可以表达，要么为0，要么为1，将兑换码id作为偏移量，记录当前兑换码状态，那么使用4个字节的数据可以存储2^32个兑换码的状态，而且Redis作为内存数据，查询效率也很高。
因此当我们兑换成功后，使用setbit将对应的bit位置为1，校验通过，接着查询兑换码，从而得到优惠券id，查询优惠券，将优惠券使用数量+1。

# 并发安全问题
## 解决方案
针对并发安全问题，最广为人知的解决方案就是加锁。从实现思想上来说，锁可以分为两大类：
* 悲观锁：独占和排他的锁机制，保守地认为数据会被其他事务修改，所以在整个数据处理过程中将数据处于锁定状态
* 乐观锁：较为乐观的并发控制方法，假设多用户并发不会产生安全问题，因此无需独占和锁定资源，但在更新数据前，会先检查是否有其他的线程修改了数据。如果有，则认为可能有风险，会放弃修改操作。

# 事务失效问题
## 事务方法非public修饰
由于Spring的事务是基于AOP的方式结合动态代理来实现的。因此事务方法一定要是public的，这样才能便于被Spring做事务的代理和增强

## 非事务方法调用事务方法
事务方法是被Spring事务管理，Spring对于事务方法的增强是通过生成动态代理对象增强的。非实物方法调用事务方法时，从Jvm的角度出发，在栈帧的局部变量表的第一个位置是this引用，那么这时候调用事务方法的就不是代理对象，而是原始的对象。

## 事务方法的异常被捕获
Spring的事务管理就是要感知业务方法的异常，当捕获到异常后才会回滚事务，异常被捕获后，会导致Spring无法感知事务异常，自然不会回滚，事务失效

## 事务异常类型不对
Spring的事务管理默认感知的异常类型是`RuntimeException`，当事务方法内部抛出了一个`IOException`时，不会被Spring捕获，因此就不会触发事务回滚，事务就失效了

因此，当我们的业务中会抛出RuntimeException以外的异常时，应该通过`@Transactional`注解中的`rollbackFor`属性来指定异常类型：
```
@Transactional(rollbackFor = Exception.class)
```

## 事务传播行为不对

## 没有被Spring管理
没有被Spring管理。你在方法上添加的`@Transactional`注解根本不会有人帮你动态代理，事务自然失效。