****
#### 今日面试题总结
1. 项目中你在哪里使用了MQ?为什么使用MQ?
	用户购买课程支付成功之后交易微服务trade-service使用rabbitmq发送异步通知
	学习微服务learning-service添加课程到课表，因为添加课程到课表的流程不能与购买课程的业务耦合，我们知道rabbitmq的一大优点就是服务解耦，所以使用mq异步调用。
 2. 你是如何设计表的？
	我是结合需求说明书和原型图分析出表字段，然后使用三范式的设计规则进行设计
3. 什么是三范式？
	第一范式：字段不可拆分
	第二范式：一张表描述一件事
	第三范式：表中的字段不可以依赖非主键字段以及有更深层次的依赖（不要有冗余数据，可以算出的数据不保存）
	反三范式：允许少量冗余数据，方便查询以及业务的需要
4. ThreadLocal底层原理？
	线程的本地变量，ThreadLocal内部维护了一个类似Map的ThreadLocalMap数据结构，当执行set方法时，ThreadLocal首先获取当前线程对象，然后获取当前线程的ThreadLocalMap对象，在以当前ThreadLocal对象为key，将值存储进ThreadLocalMap对象中，get()方法执行过程类似，ThreadLocal首先会获取当前线程对象，然后获取当前线程的ThreadLocalMap对象，以当前ThreadLocal对象为key，获取对应的value，因为每个线程军含有各自私有的ThreadLocalMap容器，线程私有相互独立互不影响，因此不会存在线程安全问题。
5. ThreadLocal的key为什么是弱引用,引用类型有哪些,区别是什么?
	设置成弱引用的原因是为了防止内存泄漏
	> 内存泄漏：JVM中某些不再需要使用的对象，仍然存活于JVM中而不能及时回收而导致的内存空间的浪费
	把key设置为弱引用，就是下一次GC的时候，将弱引用指向的对象回收，为了避免多个线程依赖同一个ThreadLocal引用，其中一个线程使用结束想要释放内存，假设是强引用的情况下，导致ThreadLocal的Entry占用的内存无法释放，出现内存泄漏的现象
	> 强引用：类似Object obj = new Object()这类的引用，就是强引用，只要强引用存在，垃圾回收器永远不会回收被引用的对象。
	> 软引用：一种相对强引用弱化一些的引用，可以让对象豁免一些垃圾收集，只有当JVM认为内存不足时，才会试图去回收弱引用指向的对象。通常用来实现内存敏感的缓存，如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理
	> 弱引用：每次JVM进行垃圾回收时，无论内存是否充足，都会回收只被弱引用关联的对象
	> 虚引用：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，它仅仅是提供了一种确保对象被finalize以后，做某些事情的机制
6. 内存溢出和内存泄漏的区别？
	内存溢出：申请内存时，JVM没有足够的内存空间
	内存泄漏：JVM中某些不再需要使用的对象，仍然存活于JVM中而不能及时回收而导致的内存空间的浪费