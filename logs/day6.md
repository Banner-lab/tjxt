****
#### Redis键值设计
##### 优雅的key结构
Reis中key设计，建议遵循以下几个实践约定：
* 遵循基本格式：[业务名称]:[数据名]:[id]
* 长度不超过44字节
* 不包括特殊字符
其中不超过44字节是因为key是string类型，底层编码包括int、embstr和raw三种。embstr在小于44字节使用，采用连续内存空间，内存占用更小

##### 拒绝BigKey
BigKey通常以Key的大小和Key中的成员数量来综合判定，推荐单个Key的value小于10kb，对于集合类型的key，建立元素数量小于1000
BigKey的危害
- 网络阻塞
- 数据倾斜
- Redis阻塞
- CPU压力
**如何删除BigKey?**
BigKey内存占用较多，即使删除这样的key也需要耗费很长时间，导致Redis主线程阻塞，引发一系列问题
1. Redis3.0及以下版本
	如果是集合类型，则遍历BigKey的元素，先逐个删除子元素，最后删除BigKey
2. Redis4.0以后
	Redis在4.0以后提供了异步删除的命令：unlink

##### 恰当的数据类型
比如存储一个User对象，我们可以选择三种存储方式
**json字符串:**
> user:1 | {"name" : "jack","age":21}

优点实现简单粗暴，但是数据耦合，不够灵活，修改某个属性时必须用另一个json字符串替换
**字段打散:**
不同的属性使用不同的string类型key存储，优点是可以灵活访问对象任意字段，缺点是占用空间大、没办法做统一控制，当我们想要访问对象的所有信息时需要一个一个字段的取
**hash：**
底层使用ziplist，空间占用小，可以灵活访问对象的任意字段；缺点是代码实现相对复杂
> hash的entry数量超过500时，会使用哈希表而不是ziplist，内存占用较多

##### Value的最佳实践
* 合理的拆分数据，拒绝BigKey
* 选择合适数据结构
* Hash结构的entry数量不要超过1000
* 设置合理的超时时间


#### 批处理优化
Redis一次命令的响应时间=1次往返的网络传输耗时+1次Redis执行命令耗时
**N条命令批量执行**
N次命令的响应时间=1次往返的网络传输耗时+N次Redis执行命令耗时
###### MSET
Redis提供了很多Mxxx这样的命令，可以实现批量插入数据，例如：
* mset
* hmset
示例，利用mset批量插入10万条数据
```
@Test
public void testMxx(){
	String[] arr = new String[2000];
	int j;
	for(int i = 1 ; i <= 100000 ; i++){
		j = ( i % 1000) << 1;
		arr[j] = "test:key:"+i;
		arr[j+1] = "value_" + i;
		if(j == 0){
			jedis.mset(arr);
		}
	}
}
```
**不要一次批处理中传输太多命令，否则单次命令占用带宽过多，会导致网络阻塞**
###### Pipeline
MSET虽然可以批处理，但是却只能操作部分数据类型，因此如果有对复杂数据类型的批处理需要，建议使用pipeline功能
**Pipeline的多个命令之间不具备原子性**
